\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, systeme, mathtools, lmodern, float, graphicx}
\usepackage[most]{tcolorbox}
\usepackage[scale=.95,type1]{cabin}
\usepackage[framemethod=tikz]{mdframed}

\usepackage[legalpaper,margin=1in]{geometry}

\setlength{\parindent}{10pt}
\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.2}

\title{Chapter 7: Eigenvalues and Eigenvectors}
\date{}

\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
  \hskip -\arraycolsep
  \let\@ifnextchar\new@ifnextchar
  \array{#1}}
\makeatother

\newcommand\y{\cellcolor{blue!10}}

\usepackage{tabularray}
\SetTblrInner{colsep=5pt,rowsep=1pt}

\newcommand\x{\times}
\newcommand\xor{\oplus}

\makeatletter
\newcommand{\dashover}[2][\mathop]{#1{\mathpalette\df@over{{\dashfill}{#2}}}}
\newcommand{\fillover}[2][\mathop]{#1{\mathpalette\df@over{{\solidfill}{#2}}}}
\newcommand{\df@over}[2]{\df@@over#1#2}
\newcommand\df@@over[3]{%
  \vbox{
    \offinterlineskip
    \ialign{##\cr
      #2{#1}\cr
      \noalign{\kern1pt}
      $\m@th#1#3$\cr
    }
  }%
}
\newcommand{\dashfill}[1]{%
  \kern-.5pt
  \xleaders\hbox{\kern.5pt\vrule height.4pt width \dash@width{#1}\kern.5pt}\hfill
  \kern-.5pt
}
\newcommand{\dash@width}[1]{%
  \ifx#1\displaystyle
    2pt
  \else
    \ifx#1\textstyle
      1.5pt
    \else
      \ifx#1\scriptstyle
        1.25pt
      \else
        \ifx#1\scriptscriptstyle
          1pt
        \fi
      \fi
    \fi
  \fi
}
\newcommand{\solidfill}[1]{\leaders\hrule\hfill}
\makeatother

\newcommand\R{\mathbb{R}}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\DeclarePairedDelimiter\norm{\lVert}{\rVert}%

% Swap the definition of \abs* and \norm*, so that \abs
% and \norm resizes the size of the brackets, and the 
% starred version does not.
\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
%
\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother

\newcommand*{\Value}{\frac{1}{2}x^2}%

\newcommand\ddfrac[2]{\frac{\displaystyle #1}{\displaystyle #2}}


\newcounter{Theo}[section]
\newenvironment{Theo}[1][]{%
  \stepcounter{Lemma}%
  \ifstrempty{#1}%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{\textit{THEOREM}}~};}}
  }%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{\textit{THEOREM}}~:~\color{blue5}{#1}};}}%
  }%
  \mdfsetup{innertopmargin=10pt,linecolor=blue!20,%
            linewidth=1pt,topline=true,%
            frametitleaboveskip=\dimexpr-\ht\strutbox\relax,}
  \begin{mdframed}[]\relax%
  }{\end{mdframed}}

\newcounter{Def}[section]
\newenvironment{Def}[1][]{%
  \ifstrempty{#1}%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{Definition}~};}}
  }%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{Definition}~:~\color{blue4}{#1}};}}%
  }%
  \mdfsetup{innertopmargin=2pt,linecolor=blue!20,%
            linewidth=1pt,topline=true,%
            frametitleaboveskip=\dimexpr-\ht\strutbox\relax,}
  \begin{mdframed}[]\relax%
  }{\end{mdframed}}

\newcounter{Ans}[section]
\newenvironment{Ans}[1][]{%
  \ifstrempty{#1}%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{\textit{ANSWER}}~};}}
  }%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{\textit{ANSWER}}~:~\color{blue4}{#1}};}}%
  }%
  \mdfsetup{innertopmargin=2pt,linecolor=blue!20,%
            linewidth=1pt,topline=true,%
            frametitleaboveskip=\dimexpr-\ht\strutbox\relax,}
  \begin{mdframed}[]\relax%
  }{\end{mdframed}}

\newcounter{Ques}[section]
\newenvironment{Ques}[1][]{%
  \ifstrempty{#1}%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{blue5}{\textit{QUESTION}}~};}}
  }%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{\textit{ANSWER}}~:~\color{blue4}{#1}};}}%
  }%
  \mdfsetup{innertopmargin=2pt,linecolor=blue!20,%
            linewidth=1pt,topline=true,%
            frametitleaboveskip=\dimexpr-\ht\strutbox\relax,}
  \begin{mdframed}[]\relax%
  }{\end{mdframed}}


\newcounter{Conc}[section]
\newenvironment{Conc}[1][]{%
  \ifstrempty{#1}%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{blue5}{Conclude}~};}}
  }%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{\textit{ANSWER}}~:~\color{blue4}{#1}};}}%
  }%
  \mdfsetup{innertopmargin=0pt,linecolor=blue!20,%
            linewidth=1pt,topline=true,%
            frametitleaboveskip=\dimexpr-\ht\strutbox\relax,}
  \begin{mdframed}[]\relax%
  }{\end{mdframed}}

\newcounter{Summarize}[section]
\newenvironment{Summarize}[1][]{%
  \ifstrempty{#1}%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{blue5}{\textit{SUMMARY}}~};}}
  }%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{\textit{SUMMARY}}~:~\color{blue4}{#1}};}}%
  }%
  \mdfsetup{innertopmargin=0pt,linecolor=blue!20,%
            linewidth=1pt,topline=true,%
            frametitleaboveskip=\dimexpr-\ht\strutbox\relax,}
  \begin{mdframed}[]\relax%
  }{\end{mdframed}}


\begin{document}
    \begin{Def}[Functional Programming]
        A computer programming paradigm that relies on fucntions modeled on mathematical
        functions.
    \end{Def}
    The essence of functional programming is that programs are combinations of expressions.
    Expressions include conrete values, variables, and also functions.

    Functions are expressions that are applied to an argument or input, and once applied,
    can be reduced or evaluated.

    The word \textit{purity} in functional programming is sometimes also used to mean 
    what is more properly called \textit{referential transparency}. Referential transparency means
    that the same function, given the same values to evaluate, will always return the same
    result in pure functional programming, as they do in math.

    \begin{Def}[What is a function?]
        A function is a relation between a set of possible inputs and a set of possible
        outputs. The input set is known as the domain, and the set if possible outputs
        for the function is called the codomain. The subset of the codomain that contains
        possible outputs related to different inputs is know as the image.
    \end{Def}

    \section{The structure of lambda terms}
    THe lambda calculus has 3 basic components, or \textit{lambda terms}: expressions, variables, and
    abstractions.
    \begin{itemize}
        \item expression    : refers to a superset of all those things.\\
            An expression can be a variable name, an abstraction, or a combination of those.
        \item abstraction   : a function. It is a lambda term that has a head (a lambda) and a body
            and is applied to an argument (an input value).
            \begin{equation*}
                \lambda x . x
            \end{equation*}
    \end{itemize}

    \section{Alpha equivalence}
    Same function, fx.x=fy.y

    \section{Beta reduction}
    \begin{Def}[Beta reduction]
        When applying a function to an argument, we substiture the input expression for all
        instances of bound variables within the body of the abstraction. We also eliminate
        the head of abstraction, since its onlu purpiose was to bind a variable.
    \end{Def}
    \begin{equation*}
        \begin{split}
            (\lambda x . x) & 2\\
                           & 2
        \end{split}
    \end{equation*}
    This function is the \textit{identity} function. And applications in the lambda calculus
    are \textit{left associative.}

    \subsection{Free variables}
    Free variables are those in the body expression that are not named in the head.
    \begin{equation*}
        \lambda x . xy
    \end{equation*}
    Alpha equivalence does not apply to free variables.

    \section{Multiple arguments}
    \begin{equation*}
        \lambda xy . xy \to \lambda x (\lambda y . xy)
    \end{equation*}

    \section{Evaluation is simplification}

    \begin{Def}[Beta normal form]
        Beta normal form is when you cannot beta reduce the terms any further.
        This corresponds to a fully evaluated expression.

        Eg: 2000/1000 and 2.
    \end{Def}

    \section{Combinators}
    \begin{Def}
        A comibnator is a lambda term with no free variables. Combinators serve only
        to combine the arguments they are given.
    \end{Def}

    \section{Divergence}
    \begin{equation*}
        (\lambda x.xx)(\lambda x.xx)
    \end{equation*}

    \section{Definition}
    1. A lambda abstraction is an anonymous function or lambda term. $(\lambda x. x+1)$\\
    2. Application is reducing lambdas, which binds the argument to whatever the lambda 
    was applied to.
    \begin{equation*}
        (\lambda x.x) 1
    \end{equation*}
    3. Lambda calculus is a formal system for expressing programs in terms of abstraction
    and application.\\
    4. Normal order is a common evaluation strategy in lambda calculi.\\
    Normal order means evaluating (beta reducing) the leftmost outermost lambdas first.
    

    








\end{document}

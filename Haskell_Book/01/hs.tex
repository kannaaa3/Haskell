\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, systeme, mathtools, lmodern, float, graphicx, titlesec, multicol}
% \usepackage[most]{tcolorbox}
\usepackage[dvipsnames]{xcolor}
\usepackage[scale=.95,type1]{cabin}
\usepackage[framemethod=tikz]{mdframed}

\usepackage[legalpaper,margin=1in]{geometry}

\setlength{\parindent}{10pt}
% \setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.2}

\title{All you need is Lambda}
\author{}
\date{}

\usepackage{tabularray}

\newcounter{Def}[section]
\newenvironment{Def}[1][]{%
  \ifstrempty{#1}%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{Definition}~};}}
  }%
  {\mdfsetup{%
    frametitle={%
      \tikz[baseline=(current bounding box.east),outer sep=0pt]
      \node[line width=1pt,anchor=east,rectangle,draw=blue!20,fill=white]
    {\strut \color{black}{Definition}~:~\color{blue4}{#1}};}}%
  }%
  \mdfsetup{innertopmargin=2pt,linecolor=blue!20,%
            linewidth=1pt,topline=true,%
            frametitleaboveskip=\dimexpr-\ht\strutbox\relax,}
  \begin{mdframed}[]\relax%
  }{\end{mdframed}}

\titleformat{\section}
  {\fontfamily{lmss}\selectfont\Large\bfseries\color{black}}
  {\thesection}{1em}{}
\begin{document}
\maketitle
    \begin{Def}[Functional Programming]
        A computer programming paradigm that relies on fucntions modeled on mathematical
        functions.
    \end{Def}
    The essence of functional programming is that programs are combinations of expressions. 
    \begin{itemize} \renewcommand\labelitemi{\small \textcolor{Lavender}{$\blacksquare$}}
      \item \textbf{Expressions} conrete values, variables, and also functions.
      \item \textbf{Functions.} Expressions that are applied to an argument or input, and once applied, can be reduced or evaluated.
      \item \textbf{Purity}: Referential transparency - the same function, same {\fontfamily{cmtt}\selectfont input}, always return the same
    result in pure functional programming, as they do in math.
\end{itemize}


    \begin{Def}[What is a function?]
        A function is a relation between a set of possible inputs and a set of possible
        outputs. 
      \begin{itemize} \renewcommand\labelitemi{\small \textcolor{Lavender}{$\blacksquare$}}
        \item \textbf{The input set.} The Domain.
        \item \textbf{The output set.} The Codomain.
        \item \textbf{The image.} The subset of the codomain that contains possible outputs related to different inputs.
      \end{itemize}
    \end{Def}

    \section{The structure of lambda terms}
    The lambda calculus has 3 basic components, or \textit{lambda terms}: expressions, variables, and
    abstractions.
    \begin{itemize} \renewcommand\labelitemi{\small \textcolor{Lavender}{$\blacksquare$}}
        \item \textbf{Expression}    : refers to a superset of all those things.\\
            An expression can be a variable name, an abstraction, or a combination of those.
        \item \textbf{Abstraction}   : a function. It is a lambda term that has a head (a lambda) and a body
            and is applied to an argument (an input value).
            \begin{equation*}
                \lambda x . x
            \end{equation*}
    \end{itemize}

    \section{Alpha equivalence}
    Same meaning: $\lambda x.x \, \equiv \, \lambda y.y \, \equiv \lambda z.z     $

    \section{Beta reduction}
    \begin{Def}[Beta reduction]
        Substitute {\fontfamily{cmtt}\selectfont input} expression for all {\fontfamily{cmtt}\selectfont variables} within the body of {\fontfamily{cmtt}\selectfont abstraction}.
    \end{Def}
    \begin{equation*}
        \begin{split}
            (\lambda x . x) & 2\\
                           & 2
        \end{split}
    \end{equation*}
    This is the \textit{identity} function. And applications in the lambda calculus
    are \textbf{left associative.}

    \begin{itemize} \renewcommand\labelitemi{\small \textcolor{Lavender}{$\blacksquare$}}
      \item \textbf{Free variables.} Variable not in the head $\lambda$, not apply \textit{alpha equivalence}.
    \begin{equation*}
        \lambda x . xy
    \end{equation*}
    \item \textbf{Multiple arguments.} $\lambda xy . xy \to \lambda x (\lambda y . xy)$
    \end{itemize}               


    \section{Evaluation is Simplification}
\begin{itemize} \renewcommand\labelitemi{\small \textcolor{Lavender}{$\blacksquare$}}
  \item \textbf{Beta normal form.} The form which cannot be reduced any further.

        Eg: not {\fontfamily{cmtt}\selectfont 2000/1000}, but {\fontfamily{cmtt}\selectfont 2}.
\end{itemize}


\section{Combinators}

A \textbf{combinator} is a lambda term with \textbf{no free variables}. Combinators are only
used \textbf{combine} the arguments. 
\begin{multicols}{3}
  \begin{itemize} \renewcommand\labelitemi{\small \textcolor{Lavender}{$\blacksquare$}}
    \item $\lambda zy . zzy$ 
    \item $\lambda x. x$
    \item $\lambda xy. y$      
  \end{itemize}
\end{multicols}

\section{Divergence}
\begin{itemize} \renewcommand\labelitemi{\small \textcolor{Lavender}{$\blacksquare$}}
  \item Reducible lambda terms \textbf{not} reduce neatly to a \textbf{beta normal form}. The reduction process \textbf{never} terminates or ends.
\[ \text{{\fontfamily{cmtt}\selectfont omega:}} \ \  (\lambda x.xx)(\lambda x.xx) \to (\lambda x.xx)(\lambda x.xx) \]  
\end{itemize}

\section{Definition}
1. A \textbf{lambda abstraction} is an anonymous function or lambda term. $(\lambda x. x+1)$\\
2. \textbf{Application} is reducing lambdas, which binds the argument to whatever the lambda 
was applied to.
\begin{equation*}
    (\lambda x.x) 1
\end{equation*}
3. Lambda calculus is a formal system for expressing programs in terms of abstraction
and application.\\
4. \textbf{Normal order} is a common evaluation strategy in lambda calculi. 
Normal order means evaluating (beta reducing) the leftmost outermost lambdas first.
    
\end{document}

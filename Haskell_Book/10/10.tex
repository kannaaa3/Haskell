\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, systeme, mathtools, lmodern, float, graphicx, listings, titlesec, fontawesome5}
\usepackage[dvipsnames]{xcolor}
\usepackage[scale=.95,type1]{cabin}
\usepackage[framemethod=tikz]{mdframed}

\usepackage[legalpaper,margin=1in]{geometry}

\setlength{\parindent}{10pt}
% \setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.2}

\title{CHAPTER 10: FOLDING LISTS}
\date{}
\author{}

\newcounter{Def}[section]
\newenvironment{Def}[1][]{%
	\ifstrempty{#1}%
	{\mdfsetup{%
		}
	}%
	{\mdfsetup{%
			frametitle={%
					\tikz[baseline=(current bounding box.east),outer sep=0pt]
					\node[line width=1pt,anchor=east,rectangle,draw=Lavender!20,fill=white]
					{\strut \color{RubineRed!80}{#1}};}}%
	}%
	\mdfsetup{innertopmargin=2pt,linecolor=Lavender!20,%
		linewidth=1pt,topline=true,%
		frametitleaboveskip=\dimexpr-\ht\strutbox\relax,}
	\begin{mdframed}[]\relax%
		}{\end{mdframed}}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.93725490196,0.94509803921,0.96078431372}
\definecolor{codewhite}{rgb}{0.75,0.78,0.84}
\definecolor{normalcode}{rgb}{0.35,0.36,0.45}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegray},
	keywordstyle=\color{magenta},
	numberstyle=\small\color{Gray!70}\fontfamily{cmtt}\selectfont,
	stringstyle=\color{codegreen},
	basicstyle=\ttfamily\color{normalcode}\footnotesize,
	breakatwhitespace=false,
	% frame=single,
	% breaklines=true,                 
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}

\lstset{style=mystyle}

\titleformat{\section}
{\fontfamily{lmss}\selectfont\LARGE\bfseries\color{black}}
{\thesection}{1em}{}
\begin{document}
\begin{Def}[Catamorphism]
	\textit{"Cata"} means "down" or "against", as in "catacombs". Catamorphisms are means of
	deconstructing data. If the spine of a list is the structure of a list, then
	a fold is what can reduce that structure.

	Where a fold allows to break down a list into an arbitrary datatype, a catamorphism
	is a means of breaking down the structure of any datatype (bool func).
\end{Def}

\section{Fold right}
\begin{lstlisting}[language = Haskell]
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z xs =
    case xs of
    []      -> z
    (x:xs)  -> f x (foldr f z xs) --<---- this one
                -- |rest of the fold|
      \end{lstlisting}

If $f$ doesn't evaluate its 2nd argument (rest of the fold), no more spine will be forced. For this
reason, foldr can be used with infinite lists.

In other words,
\begin{lstlisting}[language = Haskell]
foldr (+) 0 [2, 3] =
case [2, 3] of
    [] -> 0 -- this didn't match again
    (2 : [3]) -> (+) 2 (foldr (+) 0 [3]) -- (1+(2+(3+0)))\end{lstlisting}

Since {\fontfamily{cmtt}\selectfont (+)} is \textbf{strict in both arguments}, and also \textit{unconditionally} so, so it jump to the \textbf{next recursion}. Bouncin' between $f$ -  {\fontfamily{cmtt}\selectfont foldr}, give controls to the folding functions.

The difference between {\fontfamily{cmtt}\selectfont foldl} and {\fontfamily{cmtt}\selectfont foldr} is just how it associates, or - direction of folding.
\begin{lstlisting}[language = Haskell]
-- not strict in both args
Prelude> myAny even [1..]
True  
-- but not this 
Prelude> myAny even (repeat 1) -- bottom
    \end{lstlisting}

The first piece of the spine, the first {\fontfamily{cmtt}\selectfont :} (cons) can't be {\fontfamily{cmtt}\selectfont undefined} for folding. Since {\fontfamily{cmtt}\selectfont f x} forces the {\fontfamily{cmtt}\selectfont (x:xs)}.
\begin{lstlisting}[language = Haskell]
foldr f z (x:xs) = f x (foldr f z xs)
      -- see there
Prelude> foldr (\_ _ -> 9001) 0 [undefined, undefined] --9001
Prelude> foldr (\_ _ -> 9001) 0 ([1, 2, 3] ++ undefined) -- 9001
Prelude> foldr (\_ _ -> 9001) 0 undefined -- or undefined ++ [1,2]
*** Exception: Prelude.undefined \end{lstlisting}
\section{Fold left }
Because {\fontfamily{cmtt}\selectfont foldl} evaluate its whole spine before it starts evaluating in each cell, it accumulates
a pile of unevaluated values as it traverses the spine.
\begin{lstlisting}[language = Haskell]
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f acc []      = acc
foldl f acc (x:xs)  = foldl f (f acc x) xs  
-- ((0+1)+2)+3) \end{lstlisting}


{\fontfamily{cmtt}\selectfont foldl'} (foldl prime) works the same except it is strict, has \textbf{less negative effect} on performance
over long lists. Only beginning to produce values \textbf{after reaching the end of the list}.
Nearly useless, gotta use foldl'.
\begin{lstlisting}[language = Haskell]
scanl :: (a -> b -> a) -> a -> [b] -> [a]
scanl f q ls =
q : (case ls of              -- Wow, this is possible!
        [] -> []
        x:xs -> scanl f (f q x) xs)

-- Fibonacci numbers
fibs = 1 : scanl (+) 1 fibs
fibsN x = fibs !! x
\end{lstlisting}



\end{document}
